<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>イントロダクション</h1>
<hr/>
<p>
  この章では，Egisonの得意なパターンマッチを行うプログラムを動かしてみましょう．<br/>
  Egisonは代数的に定義されるデータ構造に対して協力なパターンマッチ機能を持っています．<br/>
  この章では，そのもっともわかりやすい例として，コレクションデータに対してパターンマッチを行うプログラムを書いてみます．<br/>
  これを動かしてみて，Egisonがどのようなものなのか感じてみてください．<br/>
</p>

<hr/>

<h2 id="run-interpreter">インタプリタを起動しよう</h2>

<p>
  インストールに成功すると，コマンドラインで<code>egison</code>と打つとEgisonのインタプリタが起動します．<br/>
  Control-Dを打つとインタプリタを終了できます．(ControlキーとDキーを同時押し)
</p>
<pre>
  <code>
% egison
Egison, version X.X.X : http://hagi.is.s.u-tokyo.ac.jp/~egi/egison/
Welcome to Egison Interpreter!
&gt; ^D
Leaving Egison.
Byebye. See you again! (^^)/
  </code>
</pre>

<p>
  いくつか，Egisonに入力を与えてみましょう．
</p>

<pre>
  <code>
&gt; (define $x 2)
x
&gt; (test (+ x 3))
5
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f x 4))
[6 8]
  </code>
</pre>

<p>
  この例では，2つのトップ式(top expression)がでてきました．<br/>
  <code>define</code>式と<code>test</code>式です．<br/>
  <code>define</code>式は1番目の引数の変数の2番目の引数の式の値への束縛をトップレベル環境に加えます．<br/>
  <code>test</code>式は1番目の引数の式を評価しその値を表示します．<br/>
  トップ式は，他にもあるのですが，とりあえずここではこの2つだけ覚えておいてください．<br/>
</p>

<h2 id="four-parenses">4種類の括弧</h2>

<p>
  Egisonには4種類の括弧があります．<br/>
</p>

<p>
  '<code>(</code>', '<code>)</code>' で囲まれた式は，言語に組み込まれている構文を適用する式を表すのと，
  ユーザ定義した関数を適用する式を表すのに使われます．<br/>
  小囲まれた式のうちで先頭にあるものがオペレータで，それ以降の式が引数となります．<br/>
</p>
<p>
  '<code><</code>', '<code>></code>' で囲まれた式は，データコンストラクタの適用を表します．<br/>
  囲まれた式のうちで先頭の式がデータコンストラクタで，それ以降の式が引数となります．<br/>
  '<code><</code>', '<code>></code>' で囲まれた式は，パターンコンストラクタ(pattern constructor)の適用を表すのにも使われます．．<br/>
  パターンコンストラクタはデータコンストラクタと呼び方を変えただけで，同じものです．後で説明します．<br/>
</p>
<p>
  '<code>[</code>', '<code>]</code>' で囲まれた式はタプルを表しています．<br/>
  Egisonのタプルは多値として使うことができます．1つの式しか含んでいないタプルはその1つの式と同値になります．<br/>
</p>

<pre>
  <code>
1 = [1] = [[1]] = ...
  </code>
</pre>

<p>
  '<code>{</code>', '<code>}</code>' で囲まれた式はコレクション(任意個の同じ種類の要素からなるデータ)を表します．<br/>
  囲まれている式には先頭に'<code>@</code>' がついていない式とついている式との2種類があります．<br/>
  '<code>@</code>' がついていない式は，全体のコレクションの要素の1つとして扱われます．<br/>
  '<code>@</code>' がついている式は，全体のコレクションの部分コレクション(subcollection)として扱われます．<br/>
</p>

<pre>
  <code>
{1 @{2 3 4} @{5 @{6} 7} 8} = {1 2 3 4 5 6 7 8}
  </code>
</pre>
  
<h2 id="four-parenses"><code>lambda</code>と<code>let</code></h2>

<p>
  <code>lambda</code>構文は，1つ目の引数にパターン変数(pattern variable)のタプルをとります．<br/>
  パターン変数というのは，先頭に'<code>$</code>'がついている文字列のことです．<br/>
  これからでそこで束縛される変数を表します．<br/>
  2つ目の引数に関数適用した際に実行する式をとります．<br/>
</p>
<p>
  関数適用の式には，<code>apply</code>構文を用いたものと，
  適用する関数と引数を並べて，'<code>(</code>' と '<code>)</code>'によって囲ったものがあります，<br/>
  <code>apply</code>構文は，1つ目の引数に適用する関数をとります．<br/>
  2つ目の引数に適用する式を書きます．<br/>
  適用する関数と引数を並べて，'<code>(</code>' と '<code>)</code>' によってで囲った式は，
  <code>apply</code>構文の糖衣構文です．
</p>
<pre>
  <code>
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f 2 4))
[6 8]
&gt; (test (apply f [2 4]))
[6 8]
&gt; (test (apply f (f 2 4)))
[14 48]
  </code>
</pre>

<p>
  <code>let</code>構文は，1つ目の引数にパターン変数と式のタプルのコレクションをとります．<br/>
  その式を評価した値をパターン変数に束縛します．<br/>
  Egisonの<code>let</code>は，相互再帰的な束縛をします．<br/>
  その束縛を現環境追加して，2つ目の引数の式を実行します．<br/>
</p>
<pre>
  <code>
&gt; (test (let {[$f (lambda [$x] (+ (g x) 10))]
              [$g (lambda [$x] (+ x 1))]}
          (f 0)))
11
  </code>
</pre>

<h2 id="four-parenses">パターンマッチしてみよう</h2>

<p>
  パターンマッチを行うコードを動かしてみましょう．<br/>
  この節では，そのなかでもわかりやすいコレクションのパターンマッチを書いてみます．<br/>
  この節に出てくるコードを実行するには，<code>lib/base.egi</code>と，<code>lib/number.egi</code>，<code>lib/collection.egi</code>をロードする必要があります．<br/>
  <code>load</code>式はトップ式で，1つ目の引数で指定されたファイルの内容を読み込みます．<br/>
  (<code>load</code>式は，現在実装されていません．<br/>
  <code>lib/collection.egi</code>の中身をコピーして手動で読み込ませてください．<br/>
  近々実装する予定です．)
</p>

<pre>
  <code>
&gt; (load "/path/to/lib/base.egi")
&gt; (load "/path/to/lib/number.egi")
&gt; (load "/path/to/lib/collection.egi")
  </code>
</pre>

<p>
  では，パターンマッチを行うコードを動かしてみましょう．<br/>
</p>

<pre>
  <code>
&gt; (test (match {2 7 7 2 7} (Multiset Int)
          {[&lt;cons $m
             &lt;cons ,m
              &lt;cons ,m
               !&lt;cons $n
                 !&lt;cons ,n
                   !&lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [_ &lt;ko&gt;]})
&lt;ok&gt;
  </code>
</pre>

<p>
  <code>match</code>構文は1つ目の引数にパターンマッチのターゲット(target)を，
  2つ目の引数にパターンマッチを行う際の型(type)を，
  3つめの引数にマッチ節(match clause)のコレクションをとります．<br/>
  この式は，<code>{2 7 7 2 7}</code>というコレクションを，
  <code>(Multiset Int)</code>としてパターンマッチするという意味になります．<br/>
  <code>(Multiset Int)</code>という式は，整数のマルチセットという意味です．<br/>
  (マルチセットというのは，要素の順序関係は無視するが，重複は考えるコレクションデータ型のことです．)<br/>
</p>

<p>
  マッチ節は，パターン(pattern)とパターンマッチが成功した際に実行される式からなるタプルとして表されます．<br/>
  <code>match</code>式が実行される際，先頭のマッチ節から順に，パターンマッチに成功するかどうかみていきます．<br/>
  パターンマッチに成功したパターンがあれば，パターンマッチによって計算された束縛フレーム(binding frame)を現環境に追加して，その節の式を評価します．<br/>
  Egisonでは，パターンマッチによる束縛フレームが複数ある場合があります．<br/>
  その場合，複数ある束縛フレームの1つが選ばれます．
  (仕様上ではどの束縛を選んでもよいことになっているのですが，先頭の束縛フレームを選ぶように実装しています．)<br/>
</p>

<p>
  1つ目のマッチ節のパターンは，ターゲットが要素5つのコレクションで同じ要素が3つあり，残り2つの要素も同じである場合にパターンマッチに成功します．<br/>
  Egisonではパターンの左側から順にパターンマッチしていきます．<br/>
  Egisonのパターンマッチはnon-left-linearになっています．<br/>
  non-left-linearは，パターンに現れたパターン変数に束縛される値を，それより右側で参照できるという意味です．<br/>
  '<code>,</code>' が先頭についたパターンは，バリューパターン(value pattern)です．<br/>
  評価されその値とターゲットを比較して同じだった場合パターンマッチに成功します．<br/>
  その際の評価で，左側のパターン変数に束縛された値を参照できます．<br/>
  パターンマッチは，常にパターンの左側から順に行われていきます．<br/>
  '<code>!</code>' が先頭についたパターンは，カットパターン(cut pattern)です．<br/>
  複数のマッチ可能な候補があっても，そのうち1つだけを残してパターンマッチを続けます．<br/>
  カットパターンは不必要なバックトラックをなくすために使われます．<br/>
  この場合は，5枚中同じ数のカードが3枚あるのは1パターンしかないので，もし，その組み合わせが見つかれば，それ以上のバックトラックは必要ないのでそれを表現している．<br/>
</p>

<p>
  2つ目のマッチ節のパターンは，ターゲットが何でもパターンマッチに成功します．<br/>
  '<code>_</code>' はワイルドカード(wild card)であり，何に対しもパターンマッチ成功します．<br/>
</p>

<p>
  Egisonでは，パターンはファーストクラスオブジェクトです．<br/>
  パターンも他の式と同じように評価したり，関数の引数として渡したりすることができます．<br/>
</p>

<pre>
  <code>
&gt; (test (let {[$pat &lt;cons ,1 &lt;nil&gt;&gt;]}
          (match {1} (Multiset Int)
            {[pat &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
&gt; (test (let {[$loop &lt;cons ,1 (of {&lt;nil&gt; loop})&gt;]}
          (match {1 1 1 1} (Multiset Int)
            {[loop &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
  </code>
</pre>

<p>
  Egisonには，<code>with</code>構文というのがあって，それを用いると新たに変数を束縛せずに再帰的定義を行うことができます．<br/>
  この例は，上の例の2つ目の例と同じ意味です．
</p>

<pre>
  <code>
&gt; (test (match {1 1 1 1} (Multiset Int)
          {[(with $loop &lt;cons ,1 (of {&lt;nil&gt; loop})&gt;) &lt;ok&gt;]
           [_ &lt;ko&gt;]}))
&lt;ok&gt;
  </code>
</pre>

<p>
  次は，パターンマッチによる束縛フレームが複数あって面白い例をみてみましょう．<br/>
  <code>match-map</code>構文は，<code>match</code>構文と同じく1つ目の引数にターゲットを，2つ目の引数に型をとります．<br/>
  ただ違うのは，3つめの引数で，マッチ節のコレクションではなく，単独のマッチ節をとります．<br/>
  パターンとターゲットを，指定された型としてパターンマッチを実行し，得られた束縛フレームのコレクションの全ての束縛フレームについて，
  それぞれマッチ節の式を実行し，その結果をコレクションにして返します．<br/>
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}

&gt; (test (match-all {1 2 3} (Multiset Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{2} {1 3}] [{2 3} {1}] [{1} {2 3}] [{1 3} {2}] [{1 2} {3}] [{1 2 3} {}]}
          
&gt; (test (match-all {1 2 3} (Set Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{3} {1 2 3}] [{2} {1 3}] [{2} {1 3 2}] [{2 3} {1}] [{2 3} {1 3}] [{2 3} {1 2}] [{2 3} {1 2 3}]
 [{1} {2 3}] [{1} {2 3 1}] [{1 3} {2}] [{1 3} {2 3}] [{1 3} {2 1}] [{1 3} {2 1 3}] [{1 2} {3}] [{1 2} {3 2}] [{1 2} {3 1}] [{1 2} {3 1 2}]
 [{1 2 3} {}] [{1 2 3} {3}] [{1 2 3} {2}] [{1 2 3} {2 3}] [{1 2 3} {1}] [{1 2 3} {1 3}] [{1 2 3} {1 2}] [{1 2 3} {1 2 3}]}
  </code>
</pre>

<p>
  パターンコンストラクタ<code>join</code>は引数を2つ取ります．<br/>
  1つ目の引数にマッチした値と2つ目の引数にマッチした値を合わせた要素が，ターゲットと同値であればパターンマッチします．<br/>
  パターンコンストラクタ毎のパターンマッチの方法の詳しい記述は型の定義のところで記述されます．<br/>
  次節で型定義について概説します．
</p>

<p>
  他にも例をいくつかあげておきます．
</p>

<pre>
  <code>
&gt; (test (match {5 2 1 3 4} (Multiset Int)
          {[&lt;cons $n
             &lt;cons ,(- n 1)
              &lt;cons ,(- n 2)
               &lt;cons ,(- n 3)
                &lt;cons ,(- n 4)
                 &lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [ _ &lt;ko&gt;]}))
&lt;ok&gt;
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs &lt;cons $x $ts&gt;&gt; [hs x ts]]))
{[{} 1 {2 3}] [{1} 2 {3}] [{1 2} 3 {}]}
&gt; (test (match-all {1 2 3 4 5} (Multiset Int)
          [&lt;cons $n $rest&gt; [m rest]]))
{[1 {2 3 4 5}] [2 {1 3 4 5}] [3 {1 2 4 5}] [4 {1 2 3 5}] [5 {1 2 3 4}]}
  </code>
</pre>

<h2 id="four-parenses">型の定義方法</h2>

<p>
  この節では，型の定義方法について概説します．<br/>
  例として多重集合(同じ要素の重複を考慮する集合)の型の定義をみてみます．<br/>
</p>

<pre>
  <code>
(define $Multiset
  (lambda [$a]
    (type
      {[$var-match (lambda [$tgt] {tgt})]
       [$inductive-match
        (deconstructor
          {[nil []
            {[{} {[]}]
             [_ {}]
             }]
           [cons [a (Multiset a)]
            {[$tgt (map (lambda [$t] [t ((remove a) tgt t)])
                        tgt)]
             }]
           [join [(Multiset a) (Multiset a)]
            {[$tgt (map (lambda [$ts] [ts ((remove-collection a) tgt ts)])
                        (subcollections tgt))]
             }]
           })]
       [$equal? (lambda [$val $tgt]
                  (match [val tgt] [(Multiset a) (Multiset a)]
                    {[[&lt;nil&gt; &lt;nil&gt;] &lt;true&gt;]
                     [[&lt;cons $x $xs&gt;
                       &lt;cons ,x ,xs&gt;]
                      &lt;true&gt;]
                     [[_ _] &lt;false&gt;]}))]
       })))
  </code>
</pre>

<p>
  <code>Multiset</code>は，型を1つ受け取って，その型の多重集合の型を返す関数となっています．<br/>
  例えば，<code>(Multiset Number)</code>は，数の多重集合という型になり，
  <code>(Multiset (Multiset (Number)))</code>は，数の多重集合の多重集合という型になります．<br/>
  <code>type</code>式を用いて，型を定義しています．<br/>
  <code>type</code>式は，引数に，<code>let</code>式の1つ目の引数と同じくパターン変数と式のタプルのコレクションをとります．<br/>
  <code>let</code>式と同じく相互再帰的な値の定義を行うことができます．<br/>
  <code>type-ref</code>式を用いると<code>type</code>式で定義した値を参照することができます．<br/>
</p>

<pre>
  <code>
> (define $t (type {[$a 2] [$f (lambda [$x] (+ x 10))]}))
t
> (test (type-ref t a))
2
> (test (type-ref t f))
#&lt;function&gt;
> (test ((type-ref t f) 2))
12
  </code>
</pre>

<p>
  <code>Multiset</code>の型の定義では，<code>var-match</code>関数と，<code>inductive-match</code>関数，<code>equal?</code>関数を定義しています．<br/>
  この3つの関数を使って，マッチ関数(match function)が構成されます．<br/>
  マッチ関数は，パターンとターゲットを受け取って，可能な束縛のコレクションを返す関数です．<br/>
</p>

<p>
  <code>var-match</code>関数，<code>equal</code>関数，<code>inductive-match</code>関数の順で説明していきます．
</p>

<p>
  <code>var-match</code>関数は，パターンが変数パターンである場合に使われます．<br/>
  <code>var-match</code>関数に，ターゲットを適用した返り値のコレクションが，そのパターン変数の取りうる値の範囲となります．
</p>

<p>
  <code>equal?</code>関数は，パターンがバリューパターンである場合に使われます．<br/>
  <code>equal?</code>関数に，バリューパターンの中身の値とターゲットとを適用した返り値の真偽値が，パターンマッチ可能かどうかを示します．<br/>
</p>

<p>
  <code>inductive-match</code>関数は，パターンがインダクティブパターン(inductive pattern)である場合に使われます．<br/>
  インダクティブパターンとは，パターンコンストラクタを用いて構成されたパターンのことです．<br/>
  <code>inductive-match</code>関数は，<code>deconstructor</code>式を用いて定義されます．<br/>
  <code>deconstructor</code>式は，デコンストラクトマッチ節(deconstructor-match clause)のコレクションを引数に取ります．<br/>
</p>

<p>
  デコンストラクトマッチ節は，パターンコンストラクタ，コンストラクタの引数の型のタプル，
  プリミティブマッチ節(primitive match clause)のコレクションからなります．<br/>
</p>

<p>
  例として，まず<code>cons</code>のデコンストラクトマッチ節をみてみます．<br/>
  デコンストラクトマッチ節の2つ目の要素に<code>[a (Multiset a)]</code>とあるのは，
  パターンのパターンコンストラクタが<code>cons</code>であった場合，
  1つ目の引数は型<code>a</code>として，2つ目の引数は型<code>(Multiset a)</code>として，
  再帰的にパターンマッチするということを表しています．<br/>
</p>

<p>
  デコンストラクトマッチ節の3つ目の要素は，プリミティブマッチ節のコレクションです．<br/>
  プリミティブマッチ節は，プリミティブパターン(primitive pattern)と式のタプルです．<br/>
  マッチ式のターゲットが，プリミティブパターンにマッチしたら，その節の式の返り値が次のパターンマッチの再帰のターゲットになります．<br/>
</p>

<p>
  現状のEgisonで，プリミティブパターンの要素はこれから説明する7つです．<br/>
</p>

<p>
  <code>_</code>は，ワイルドカードです．ターゲットが何でもパターンマッチ成功します．<br/>
  <i>pat-var</i>は，パターン変数です．ターゲットが何でもパターンマッチに成功し，値をその変数に束縛します．<br/>
  <code>&lt;</code><i>cons prime-pat</i><code> ...&gt;</code>は，
  ターゲットが<i>cons</i>で構成されたインダクティブデータである場合にパターンマッチ成功します．<br/>
  <code>[</code><i>prime-pat</i><code> ...]</code>は，ターゲットがタプルの場合，パターンマッチします．<br/>
  <code>{}</code>は，ターゲットが空のコレクションの場合，パターンマッチします．<br/>
  <code>{</code><i>prime-pat</i><code> .</code><i>prime-pat</i><code>}</code>は，コンスパターン(cons pattern)です．<br/>
  ターゲットが1つ以上の要素を含むコレクションである場合にリストとして，パターンマッチに成功し，
  1つ目の<i>prime-pat</i>にターゲットの先頭の要素が，
  2つ目の<i>prime-pat</i>にターゲットの残りの要素コレクションが束縛されます．<br/>
  <code>{.</code><i>prime-pat</i><code> </code><i>prime-pat</i><code>}</code>は，スノックパターン(snoc pattern)です．<br/>
  ターゲットが1つ以上の要素を含むコレクションである場合にリストとして，パターンマッチに成功し，
  2つ目の<i>prime-pat</i>にターゲットの一番後ろの要素が，
  1つ目の<i>prime-pat</i>にターゲットの残りの要素コレクションが束縛されます．<br/>
</p>

<p>
  例えば，型が<code>(Multiset Int)</code>で，パターンが<code>cons</code>のインダクティブパターンで，ターゲットが<code>{1 2 3}</code>というコレクションだった場合，
  <pre>
    <code>1, {2 3}</code>
    <code>2, {1 3}</code>
    <code>3, {1 2}</code>
  </pre>
  をそれぞれ1つ目を<code>Int</code>として，2つ目を<code>(Multiset Int)</code>として，再帰的にパターンマッチしていきます．
</p>

<p>
  <code>join</code>の方は，1つ目の引数は型<code>(Multiset a)</code>として，
  2つ目の引数も型<code>(Multiset a)</code>として，再帰的にパターンマッチを行います．<br/>
  <code>nil</code>の方は，引数はなくて，再帰的にこれ以上パターンマッチを行わないことを示しています．<br/>
</p>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://hagi.is.s.u-tokyo.ac.jp/~egi/">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
