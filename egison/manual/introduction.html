<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>Introduction</h2>
<hr/>
<p>
  In this chapter, we run programs that execute pattern matching which is a specialty of Egison.<br/>
  Egison is good at to pattern match algebraic data structures.<br/>
  In this chapter, we will write programs that execute pattern matching for collections.
  Run them and feel how Egison is like!!<br/>
<hr/>

<h2 id="run-interpreter">Run Interpreter!!</h2>

<p>
  After you have installed Egison, you can run Egison interpreter with a command 'egison'.<br/>
  Typing Control-D, you can terminate the interpreter.
</p>
<pre>
  <code>
% egison
Egison, version X.X.X : http://hagi.is.s.u-tokyo.ac.jp/~egi/egison/
Welcome to Egison Interpreter!
&gt; ^D
Leaving Egison.
Byebye. See you again! (^^)/
  </code>
</pre>

<p>
  Give some inputs to Egison as below.
</p>

<pre>
  <code>
&gt; (define $x 2)
x
&gt; (test (+ x 3))
5
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f x 4))
[6 8]
  </code>
</pre>

<p>
  There are two kinds of <i>top expressions</i> in these examples.<br/>
  The <code>define</code> expressions and the <code>test</code> expressions.<br/>
  When a <code>define</code> expression is evaluated, bind which binds the variable of first argument to the second argument value added to the top level environment.<br/>
  When a <code>test</code> expression is evaluated, the expression of the first argument is evaluated and the result is displayed.<br/>
  Although there are more top expressions, we describe only these two for the present.<br/>
</p>

<h2 id="four-parenses">Four Kinds of Parentheses</h2>

<p>
  There are four kinds of parentheses in Egison.<br/>
</p>
<p>
  A expression enclosed with '<code>(</code>' and '<code>)</code>' are used to represent application of the syntax of the language, and application of the user-defined function.<br/>
  The head expression of the enclosed expression is an operator, and rests are arguments.<br/>
</p>
<p>
  A expression enclosed with '<code>&lt;</code>' and '<code>&gt;</code>' represents an inductive data.<br/>
  The head of the enclosed expression is a data constructor, and rests are arguments.<br/>
  These expressions are also used to represent application of <i>pattern constructor</i>.<br/>
  Pattern constructors are same things with data constructors.<br/>
  We will describe them later.<br/>
</p>
<p>
  A expression enclosed with '<code>[</code>' and '<code>]</code>' represents a tuple.<br/>
  A tuple is dealt as multiple values in Egison.<br/>
  A tuple which contains only one element is dealt as a singleton value.<br/>
</p>

<pre>
  <code>
1 = [1] = [[1]] = ...
  </code>
</pre>

<p>
  A expression enclosed with '<code>{</code>' and '<code>}</code>' represents a collection.<br/>
  There are two forms of inner-expressions.<br/>
  Expressions which have no '<code>@</code> at the head of the expression, and expressions which have '<code>@</code> at the head of the expression.<br/>
  A expression which has no '<code>@</code> is dealt as an element of the collection.<br/>
  A expression which have '<code>@</code> is dealt as a <i>subcollection</i> of the collection.<br/>
</p>

<pre>
  <code>
{1 @{2 3 4} @{5 @{6} 7} 8} = {1 2 3 4 5 6 7 8}
  </code>
</pre>
  
<h2 id="four-parenses"><code>lambda</code> and <code>let</code></h2>

<p>
  The <code>lambda</code> expression takes a <i>pattern variable</i> as its first argument.<br/>
  Pattern variables have '<code>$</code>' at their head.<br/>
  The <code>lambda</code> expression takes a expression to execute when applied as its second argument.<br/>
</p>

<p>
  There are two syntax for function applications.<br/>
  The <code>apply</code> expression, and expressions simply enclosed with '<code>(</code>' and '<code>)</code>'.<br/>
  The <code>apply</code> expression takes an operator function as their first argument, and arguments to apply as their second argument.<br/>
  Expressions simply enclosed with '<code>(</code>' and '<code>)</code>' takes an operator function as their first elements,
  and arguments to apply as their rest of elements.<br/>
  This is a syntax sugar of <code>apply</code>.
</p>
<pre>
  <code>
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f 2 4))
[6 8]
&gt; (test (apply f [2 4]))
[6 8]
&gt; (test (apply f (f 2 4)))
[14 48]
  </code>
</pre>

<p>
  A <code>let</code> expression takes a collection of tuples which consist of a pattern variable and an expression.<br/>
  The value of the expression which is the second element of tuple are bound to the pattern variable which is the first element of the tuple.<br/>
  Bind by the <code>let</code> expression is mutual recursive.<br/>
  The expression second argument of the <code>let</code> expression is evaluated with the new environment.<br/>
</p>
<pre>
  <code>
&gt; (test (let {[$f (lambda [$x] (+ (g x) 10))]
              [$g (lambda [$x] (+ x 1))]}
          (f 0)))
11
  </code>
</pre>

<h2 id="four-parenses">Let's do Pattern Matching!!</h2>

<p>
  Let's run codes that do pattern matching!<br/>
  In this section, we will write codes that do pattern matching for collections, which are good examples to know the characteristics of Egison.<br/>
  To run programs in this section, we need to load <code>lib/base.egi</code>, <code>lib/number.egi</code> and <code>lib/collection.egi</code>, at first.<br/>
  The <code>load</code> expression is one of top expressions.<br/>
  It is used to load a egison program file, specified by the first argument.<br/>
</p>

<pre>
  <code>
&gt; (load "/path/to/lib/base.egi")
&gt; (load "/path/to/lib/number.egi")
&gt; (load "/path/to/lib/collection.egi")
  </code>
</pre>

<p>
  So, let's execute the code below!
</p>

<pre>
  <code>
&gt; (test (match {2 7 7 2 7} (Multiset Integer)
          {[&lt;cons $m
             &lt;cons ,m
              &lt;cons ,m
               &lt;cons $n
                !&lt;cons ,n
                  !&lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [_ &lt;ko&gt;]})
&lt;ok&gt;
  </code>
</pre>

<p>
  The <code>match</code> expression takes a <i>target</i> value of pattern matching as their first argument, a <i>type</i> as their second argument, and <i>match clauses</i> as their third argument.<br/>
  This expression represents pattern matching of the collection <code>{2 7 7 2 7}</code> as the type <code>(Multiset Integer)</code>.<br/>
  <code>(Multiset Integer)</code> means multiset of integer.<br/>
  Multiset is a collection data type, in which the order of the elements is ignored, but multiplicity is significant.<br/>
</p>

<p>
  The match clause is represented as a tuple of a <i>pattern</i> and an expression which is evaluated when the pattern is matched with the target value.<br/>
  Pattern matching are executed from head of match clauses.<br/>
  If there is a pattern clause for whose pattern pattern matching succeed, the expression of the match clause is executed with the environment to which <i>binding frame</i> generated by pattern matching is added.<br/>
  There are cases many binding frames exist.<br/>
  In that case, one of binding frames is chose.<br/>
</p>

<p>
  The pattern of the first match clause matches if the target value is collection which consists of five elements, and three of these are same element and rest of two elements are same too.<br/>
  In Egison, pattern matching is executed from the left side of the pattern, and we can refer to a value bound to a pattern variable to the right of its binding position.<br/>
  The pattern ahead of which there is a '<code>,</code>' is called the <i>value pattern</i>.<br/>
  The expression after '<code>,</code>' is evaluated, and if the value is equal to the target value, pattern matching succeed.<br/>
  The pattern ahead of which there is a '<code>!</code>' is called the <i>cut pattern</i>.<br/>
  If there are several combinations of bindings to the point of the cut pattern, we take one of them and continue pattern matching for the rest of the pattern.<br/>
  Cut patterns are used to get rid of unnecessary search.<br/>
  In this sample case, there is only one combination that three same number in five of them, so there is no need for further search if we failed pattern matching after we found one combination of three same numbers.<br/>
  This cut pattern represent this fact.<br/>
</p>

<p>
  The pattern of the second match clause matches with any target values.<br/>
  '<code>_</code>' means the <i>wild card</i>.<br/>
  This pattern matches with any target values.<br/>
</p>

<p>
  In Egison, a pattern is a first class object.<br/>
  So a pattern can be a return value of a function, or we can use it as an argument of a function.<br/>
  So we can generate complex patterns as below.<br/>
</p>

<pre>
  <code>
&gt; (test (let {[$pat &lt;cons ,1 &lt;nil&gt;&gt;]}
          (match {1} (Multiset Int)
            {[pat &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
&gt; (test (let {[$loop &lt;cons ,1 (of {&lt;nil&gt; loop})&gt;]}
          (match {1 1 1 1} (Multiset Int)
            {[loop &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
  </code>
</pre>

<p>
  Next, we show examples of pattern matching whose result has several binding frames.<br/>
  The <code>match-all</code> expression takes a target value as its first argument, and a type as its second argument, as the <code>match</code> expression do.<br/>
  But it takes single match clause as its third argument, not a collection of match clause as the <code>match</code> expression do.<br/>
  When the <code>match-all</code> expression is evaluated, the expression of the match clause are executed for each binding frames and return the collection which consists of each results.<br/>
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}

&gt; (test (match-all {1 2 3} (Multiset Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{2} {1 3}] [{2 3} {1}] [{1} {2 3}] [{1 3} {2}] [{1 2} {3}] [{1 2 3} {}]}
          
&gt; (test (match-all {1 2 3} (Set Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{3} {1 2 3}] [{2} {1 3}] [{2} {1 3 2}] [{2 3} {1}] [{2 3} {1 3}] [{2 3} {1 2}] [{2 3} {1 2 3}]
 [{1} {2 3}] [{1} {2 3 1}] [{1 3} {2}] [{1 3} {2 3}] [{1 3} {2 1}] [{1 3} {2 1 3}] [{1 2} {3}] [{1 2} {3 2}] [{1 2} {3 1}] [{1 2} {3 1 2}]
 [{1 2 3} {}] [{1 2 3} {3}] [{1 2 3} {2}] [{1 2 3} {2 3}] [{1 2 3} {1}] [{1 2 3} {1 3}] [{1 2 3} {1 2}] [{1 2 3} {1 2 3}]}
  </code>
</pre>

<p>
  The pattern constructor <code>join</code> takes two arguments.<br/>
  We succeed pattern matching when the target collection is equal with the collection which consists of the elements of the collection matched with pattern of the first argument and the second argument.<br/>
  The ways of pattern matching for each pattern constructor are defined when we define the type.<br/>
  We will describe how to define types, in the next section.<br/>
</p>

<p>
  There are some other examples.<br/>
</p>

<pre>
  <code>
&gt; (test (match {5 2 1 3 4} (Multiset Int)
          {[&lt;cons $n
             &lt;cons ,(- n 1)
              &lt;cons ,(- n 2)
               &lt;cons ,(- n 3)
                &lt;cons ,(- n 4)
                 &lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [ _ &lt;ko&gt;]}))
&lt;ok&gt;
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs &lt;cons $x $ts&gt;&gt; [hs x ts]]))
{[{} 1 {2 3}] [{1} 2 {3}] [{1 2} 3 {}]}
&gt; (test (match-all {1 2 3 4 5} (Multiset Int)
          [&lt;cons $n $rest&gt; [m rest]]))
{[1 {2 3 4 5}] [2 {1 3 4 5}] [3 {1 2 4 5}] [4 {1 2 3 5}] [5 {1 2 3 4}]}
  </code>
</pre>

<h2>How To Define Types</h2>

<p>
  We need to define how to do pattern matching for each type to evaluate the pattern matching expression explained in the previous section.<br/>
  In this section, we explain how to define types and how the pattern matching expressions of Egison are executed.<br/>
  All the knowledge you need to write type definitions is included in the type definition for multiset.<br/>
  Therefore, we explain the type definition for multiset.<br/>
  Below is a definition of the multiset in Egison.<br/>
</p>

<pre>
  <code>
(define $Multiset
  (lambda [$a]
    (type
      {[$var-match (lambda [$tgt] {tgt})]
       [$inductive-match
        (deconstructor
          {[nil []
            {[{} {[]}]
             [_ {}]}]
           [cons [a (Multiset a)]
            {[$tgt (map (lambda [$t] [t ((remove a) tgt t)]) tgt)]}]
           [join [(Multiset a) (Multiset a)]
            {[$tgt (map (lambda [$ts] [ts ((remove-collection a) tgt ts)])
                        (subcollections tgt))]}]})]
       [$equal?
        (lambda [$val $tgt]
          (match [val tgt] [(Multiset a) (Multiset a)]
            {[[&lt;nil&gt; &lt;nil&gt;] &lt;true&gt;]
             [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] &lt;true&gt;]
             [[_ _] &lt;false&gt;]}))]})))
  </code>
</pre>

<p>
  The <code>remove</code> function obtains a type and returns a function that removes the value which is its first argument from the collection which is its seconds argument.<br/>
  The <code>remove-collection</code> function obtains a type and returns a function that removes all elements of the collection which is its first argument from the collection which is its seconds argument.<br/>
</p>

<p>
  The <code>Multiset</code> is defined as a function that obtains a type and returns a multiset type of that type.<br/>
  For example, <code>(Multiset Integer)</code> means multiset of integers, and <code>(Multiset (Multiset Integer))</code> means multiset of multiset of integers.<br/>
</p>

<p>
  Types are defined with <code>type</code> expressions.<br/>
  A type expression obtains a collection of tuples of a pattern variable and an expression as the first argument.<br/>
  A definition of type expressions is mutually recursive.<br/>
  With a <code>type-ref</code> expression, we can refer to the value bound by a <code>type</code> expression.<br/>
</p>

<p>
  To define <code>Multiset</code>, we need to define the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function.<br/>
  The <i>match-function</i> is constructed from these three functions.<br/>
  The match-function is function that obtains a pattern and a target value, and returns binding frames.<br/>
  The match-function is automatically constructed if we define the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function.<br/>
</p>

<p>
  Next, we describe the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function, respectively.<br/>
</p>

<p>
  The <code>var-match</code> function is used when the pattern is a <i>variable pattern</i>.<br/>
  The variable pattern is a pattern that consist of only pattern variable.<br/>
  The elements of collection value returned by applying the target value to the  <code>var-match</code> function is the values that the pattern variable would be bound.<br/>
  In this <code>Multiset</code> examples, the values that the pattern variable would be bound is only a target value.<br/>
</p>

<p>
  An <code>inductive-match</code> function is used when the pattern is a <i>inductive pattern</i>.<br/>
  An inductive pattern is a pattern that is constructed by a pattern constructor.<br/>
  We describe the <code>inductive-match</code> function in detail after an <code>equal?</code> function.<br/>
</p>

<p>
  An <code>equal?</code> function is used when pattern is a <i>value pattern</i>.<br/>
  The boolean value returned by applying the value of the target value and the value pattern to the <code>equal?</code> function shows pattern matching succeed or not.<br/>
  In this example, the <code>equal?</code> function is recursively defined.<br/>
  This <code>equal?</code> function returns <code>&lt;true&gt;</code>, if both arguments contains same element same count, and else return <code>&lt;false&gt;</code>.<br/>
</p>

<p>
  Now, we describe an <code>inductive-match</code> function.<br/>
  An <code>inductive-match</code> function is defined with a <code>deconstructor</code> expression.<br/>
  A <code>deconstructor</code> expression takes a collection of <i>deconstructor-match clause</i> as an argument.<br/>
  The deconstruct-match clause consist of a pattern constructor, an expression, whose value is a tuple of types, and <i>primitive match clause</i>.<br/>
  For example, we explain the deconstructor-match clause on <code>cons</code> for <code>Multiset</code>.<br/>
  The expression <code>[a (Multiset a)]</code> means that if the pattern constructor of the pattern is <code>cons</code>, we do pattern matching the first argument of the inductive value as the type <code>a</code>, and the second as <code>(Multiset a)</code>.<br/>
</p>

<p>
  A primitive match clause is represented as a tuple of <i>primitive pattern</i> and an expression.<br/>
  If the target value is matched with the primitive pattern of the primitive match clause, the expression of the primitive match clauses are evaluated, and the value is the next target value of recursive pattern matching.<br/>
</p>

<p>
  For example, the case that the pattern is inductive pattern <code>&lt;cons $x $xs&gt;</code>, the target is a collection <code>{1 2 3}</code> and we do pattern matching them as the type <code>(Multiset Int)</code>, pattern matching is executed using the <code>inductive-match</code> function.<br/>
  And in that case, the pattern is matched with the deconstructor-match clause of <code>cons</code>, and the target is matched with its only primitive match clause.<br/>
  And result of evaluating the expression of the primitive match clause is <code>{[1 {2 3}] [2 {1 3}] [3 {1 2}]}</code>.<br/>
  Each element of the result are the target of next pattern matching.<br/>
  Its first element is matched as <code>Int</code> and its second is matched as <code>(Multiset Int)</code>.<br/>
</p>

<p>
  We call pattern matching for primitive patterns <i>primitive pattern matching</i>.<br/>
  Primitive pattern matching returns only one binding frame, as ordinary pattern matching do.<br/>
  Primitive pattern matching is the pattern matching that human can do in their mind intuitively.<br/>
</p>

<p>
  There are 7 kinds of primitive patterns.<br/>
</p>

<pre>
primpat ::= _
          | patvar
          | &lt; cons primpat ... &t;
          | [ primpat ... ]
          | {}
          | { primpat .primpat }
          | { .primepat primepat }
</pre>

<p>
  '<code>_</code>' is wildcard.<br/>
  This matches with any value.<br/>
</p>

<p>
  <i>pat-var</i> is a pattern variable.<br/>
  This matches with any value too.<br/>
</p>

<p>
  <code>&lt;</code><i>cons</i> <i>prime-pat</i> <i>...</i> <code>&gt;</code> is an <i>inductive prime pattern</i>.<br/>
  This pattern matches when the target value is an inductive value whose constructor is <code>cons</code>.<br/>
  Pattern matchings for each arguments of the constructor are recursively executed.<br/>
</p>

<p>
  <code>[</code><i>prime-pat</i> <i>...</i> <code>]</code> is a <i>tuple prime pattern</i>.<br/>
  This pattern matches when the target value is a tuple.<br/>
  Pattern matching for each element of the tuple is recursively executed.<br/>
</p>

<p>
  <code>{}</code> is an <i>empty pattern</i>.<br/>
  This pattern matches when the target value is a empty collection.<br/>
</p>

<p>
  <code>{</code><i>prime-pat</i> <code>.</code><i>prime-pat</i><code>}</code> is a <i>cons pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The first <i>prime-pat</i> is matched with the first element of the target collection, and the second <i>prime-pat</i> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  <code>{</code><code>.</code><i>prime-pat</i> <i>prime-pat</i><code>}</code> is a <i>snoc pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The second <i>prime-pat</i> is matched with the last element of the target collection, and the first <i>prime-pat</i> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  We can define lists and sets, as we do for multisets.<br/>
  We define the type of lists as figure 2.<br/>
  In the pattern of primitive pattern match clause of <code>nil</code>, an empty pattern is used.<br/>
  In the pattern of primitive pattern match clause of <code>cons</code>, a cons pattern is used.<br/>
  In the pattern of primitive pattern match clause of <code>snoc</code>, a snoc pattern is used.<br/>
</p>

<pre>
  <code>
(define $List
  (lambda [$a]
    (type
      {[$var-match (lambda [$tgt] {tgt})]
       [$inductive-match
        (deconstructor
          {[nil []
            {[{} {[]}]
             [_ {}]}]
           [cons [a (List a)]
            {[{$x .$xs} {[x xs]}]
             [_ {}]}]
           [snoc [a (List a)]
            {[{.$xs $x} {[x xs]}]
             [_ {}]}]
           [join [(List a) (List a)]
            {[$tgt (let {[$loop (lambda [$ts]
                                  (match ts (List a)
                                    {[&lt;nil&gt; {[{} {}]}]
                                     [&lt;cons $x $xs&gt; {[{} ts] @(map (lambda [$as $bs] [{x @as} bs])
                                                                   (loop xs))}]}))]}
                   (loop tgt))]}]
           [nioj [(List a) (List a)]
            {[$tgt (let {[$loop (lambda [$ts]
                                  (match ts (List a)
                                    {[&lt;nil&gt; {[{} {}]}]
                                     [&lt;snoc $x $xs&gt; {[{} ts] @(map (lambda [$as $bs] [{@as x} bs])
                                                                   (loop xs))}]}))]}
                   (loop tgt))]}]})]
       [$equal? (lambda [$val $tgt]
                  (match [val tgt] [(List a) (List a)]
                    {[[&lt;nil&gt; &lt;nil&gt;] &lt;true&gt;]
                     [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;]
                      &lt;true&gt;]
                     [[_ _] &lt;false&gt;]}))]})))
  </code>
</pre>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://hagi.is.s.u-tokyo.ac.jp/~egi/">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
