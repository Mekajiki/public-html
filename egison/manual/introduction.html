<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>Introduction</h2>
<hr/>
<p>
  In this chapter, we run programs that execute pattern matching which is a specialty of Egison.<br/>
  Egison is good at to pattern match algebraic data structure.<br/>
  In this chapter, we write programs that execute pattern matching for collections.
  Run them and feel how Egison is like!!<br/>
<hr/>

<h2 id="run-interpreter">Run Interpreter!!</h2>

<p>
  After you have installed Egison, you can run Egison interpreter with a command 'egison'.<br/>
  Typing Control-D, you can terminate the interpreter.
</p>
<pre>
  <code>
% egison
Egison, version X.X.X : http://hagi.is.s.u-tokyo.ac.jp/~egi/egison/
Welcome to Egison Interpreter!
&gt; ^D
Leaving Egison.
Byebye. See you again! (^^)/
  </code>
</pre>

<p>
  Give some inputs to Egison as bellow.
</p>

<pre>
  <code>
&gt; (define $x 2)
x
&gt; (test (+ x 3))
5
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f x 4))
[6 8]
  </code>
</pre>

<p>
  There are two kinds of <i>top expression</i> in these expamples.<br/>
  The <code>define</code> expressions and the <code>test</code> expressions.<br/>
  When a <code>define</code> expression is evaluated, bind which binds the variable of first argument to the second argument value added to the top level environment.<br/>
  When a <code>test</code> expression is evaluated, the expression of the first argument are evaluated and the result are displayed.<br/>
  Although there are other kinds of top expressions, please note these two for the present.<br/>
</p>

<h2 id="four-parenses">Four Kinds of Parentheses</h2>

<p>
  There are four kinds of parentheses in Egison.<br/>
</p>

<p>
  Expressions surrounded with '<code>(</code>' and '<code>)</code>' are used to represent application of syntax of the language,
  and application of a user-defined function.<br/>
  The head of the surrounded expression is operator, and rests are arguments.<br/>
</p>
<p>
  Expressions surrounded with '<code>&lt;</code>' and '<code>&gt;</code>' represent inductive data.<br/>
  The head of the surrounded expression is a data constuructor, and rests are arguments.<br/>
  These expressions are also used to represent application of <i>pattern constructor</i>.<br/>
  Pattern constructors are same things with data constructors.<br/>
  We will describe them later.<br/>
</p>
<p>
  Expressions surrounded with '<code>[</code>' and '<code>]</code>' represent tuples.<br/>
  Tuples are dealt as multiple values in Egison.<br/>
  Tuple which contains only one element are dealt as sigleton value.<br/>
</p>

<pre>
  <code>
1 = [1] = [[1]] = ...
  </code>
</pre>

<p>
  Expressions surrounded with '<code>{</code>' and '<code>}</code>' represent collections.<br/>
  There are two forms of expression in the expressions in the collection.<br/>
  Expressions which have no '<code>@</code> at the head of the expression, and
  expressions which have '<code>@</code> at the head of the expression.<br/>
  Expressions which have no '<code>@</code> are dealt as an element of the collection.<br/>
  Expressions which have '<code>@</code> are dealt as an <i>subcollection</i> of the collection.<br/>
</p>

<pre>
  <code>
{1 @{2 3 4} @{5 @{6} 7} 8} = {1 2 3 4 5 6 7 8}
  </code>
</pre>
  
<h2 id="four-parenses"><code>lambda</code> and <code>let</code></h2>

<p>
  <code>lambda</code> expressions take a <i>pattern variable</i> as their first argument.<br/>
  Pattern variables have '<code>$</code>' at their head.<br/>
  <code>lambda</code> expressions take a expression to execute when applied as their second argument.<br/>
</p>

<p>
  There are two syntax for function applications.<br/>
  Expressions with <code>apply</code> expression,
  and expressions simply surrounded with '<code>(</code>' and '<code>)</code>'.<br/>
  <code>apply</code> expressions take an operator function as their first argument,
  and arguments as their second argument.<br/>
  Expressions simply surrounded with '<code>(</code>' and '<code>)</code>' takes an operator function as their first elements,
  and arguments as their rest of elements.<br/>
  This is a syntax sugar of <code>apply</code>.
</p>
<pre>
  <code>
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
f
&gt; (test (f 2 4))
[6 8]
&gt; (test (apply f [2 4]))
[6 8]
&gt; (test (apply f (f 2 4)))
[14 48]
  </code>
</pre>

<p>
  <code>let</code> expressions take a collection of tuples of pattern variable and expression.<br/>
  The value of the expression which is the second element of tuple are bound to the pattern variable which is the first element of tuple.<br/>
  Bound by <code>let</code> expressions are mutual recursive.<br/>
  The expression second argument of <code>let</code> expressions are evaluated with the new environment.<br/>
</p>
<pre>
  <code>
&gt; (test (let {[$f (lambda [$x] (+ (g x) 10))]
              [$g (lambda [$x] (+ x 1))]}
          (f 0)))
11
  </code>
</pre>

<h2 id="four-parenses">Let's do Pattern Matching!!</h2>

<p>
  Let's run codes that do pattern matchnig!<br/>
  In this section, we write codes that do pattern matching for collections,
  which are good examples to know the characteristics of Egison.<br/>
  To run programs in this section, we need to load <code>lib/base.egi</code>, <code>lib/number.egi</code> and <code>lib/collection.egi</code>.<br/>
  <code>load</code> expression is a kinds of top expression.<br/>
  It is used to load a egison program file, specified by the first argument.<br/>
</p>

<pre>
  <code>
&gt; (load "/path/to/lib/base.egi")
&gt; (load "/path/to/lib/number.egi")
&gt; (load "/path/to/lib/collection.egi")
  </code>
</pre>

<p>
  So, let's execute the code below!
</p>

<pre>
  <code>
&gt; (test (match {2 7 7 2 7} (Multiset Int)
          {[&lt;cons $m
             &lt;cons ,m
              &lt;cons ,m
               &lt;cons $n
                !&lt;cons ,n
                  !&lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [_ &lt;ko&gt;]})
&lt;ok&gt;
  </code>
</pre>

<p>
  <code>match</code> expressions take <i>target</i> of pattern matching as their first argument,
  <i>type</i> as their second argument,
  and <i>match clauses</i> as their third argument.<br/>
  This expression pattern matches a collection <code>{2 7 7 2 7}</code> as <code>(Multiset Int)</code>.<br/>
  <code>(Multiset Int)</code> means multiset of integer.<br/>
  Multiset is a collection data type, which ignore the order of the elements.<br/>
</p>

<p>
  Match clauses are represented as a tuple of a <i>pattern</i> and an expression which is evaluated when the pattern is matched with the target.<br/>
  Pattern matching are executed from head of match clauses.<br/>
  If there is a pattern for which pattern matching succeed,
  the expression of the match clause are executed with the environment to which <i>binding frame</i> generated by pattern matching are added.<br/>
  There are cases many binding frames exist.<br/>
  In that case, one of binding frames are choosed.<br/>
</p>

<p>
  The pattern of the first match clause matches if the target value is collection which consists of five elements, and three of these are same element and rest of two element are same element too.<br/>
  In Egison, pattern matching is executed  from the left side of the pattern.<br/>
  And we can refer to a value of a pattern variable to the right of its binding position.<br/>
  Patterns ahead of which there is a '<code>,</code>' is called <i>value patterns</i>.<br/>
  The expression after '<code>,</code>' is evaluated, and if the value is equal to the target value, pattern matching succeed.<br/>
  Patterns ahead of which there is a '<code>!</code>' is called <i>cut patterns</i>.<br/>
  If there are several combinations to that point, we take one of them and continue pattern matching for the rest of the pattern.<br/>
  Cut patterns are used to get rid of unnecessary search.<br/>
  In this sample case, there is only one combination that three same number cards in five cards, so there is no need for futher search if we failed pattern matching after we found these three same number cards.<br/>
  This cut pattern represent it.<br/>
</p>

<p>
  The pattern of the second match clause matches with any target.<br/>
  '<code>_</code>' is a <i>wild card</i>.<br/>
  This pattern matches with any objects.<br/>
</p>

<p>
  In Egison, patterns are first class objects.<br/>
  Patterns can be return values of functions, or we can use them as arguments of function.<br/>
</p>

<pre>
  <code>
&gt; (test (let {[$pat &lt;cons ,1 &lt;nil&gt;&gt;]}
          (match {1} (Multiset Int)
            {[pat &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
&gt; (test (let {[$loop &lt;cons ,1 (of {&lt;nil&gt; loop})&gt;]}
          (match {1 1 1 1} (Multiset Int)
            {[loop &lt;ok&gt;]
             [_ &lt;ko&gt;]})))
&lt;ok&gt;
  </code>
</pre>

<p>
  Next, we show examples that there are several binding frames.<br/>
  <code>match-all</code> expressions take a target as their first argument, and a type as their second argument, as <code>match</code> expressions do.<br/>
  But they take single match clause as their third argument, not a collection of match clause as <code>match</code> expressions do.<br/>
  When <code>match-all</code> expressions are evaluated, the expression of the match clause are executed  for each binding frames and return the collection which consists of each results.<br/>
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}

&gt; (test (match-all {1 2 3} (Multiset Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{2} {1 3}] [{2 3} {1}] [{1} {2 3}] [{1 3} {2}] [{1 2} {3}] [{1 2 3} {}]}
          
&gt; (test (match-all {1 2 3} (Set Int)
          [&lt;join $hs $ts&gt; [hs ts]]))
{[{} {1 2 3}] [{3} {1 2}] [{3} {1 2 3}] [{2} {1 3}] [{2} {1 3 2}] [{2 3} {1}] [{2 3} {1 3}] [{2 3} {1 2}] [{2 3} {1 2 3}]
 [{1} {2 3}] [{1} {2 3 1}] [{1 3} {2}] [{1 3} {2 3}] [{1 3} {2 1}] [{1 3} {2 1 3}] [{1 2} {3}] [{1 2} {3 2}] [{1 2} {3 1}] [{1 2} {3 1 2}]
 [{1 2 3} {}] [{1 2 3} {3}] [{1 2 3} {2}] [{1 2 3} {2 3}] [{1 2 3} {1}] [{1 2 3} {1 3}] [{1 2 3} {1 2}] [{1 2 3} {1 2 3}]}
  </code>
</pre>

<p>
  The pattern constructor <code>join</code> takes two arguments.<br/>
  We succeed to pattern match when the target value is equal with the value which put the value matched with pattern of the first argument and the second together.<br/>
  The ways of pattern matching for each pattern constructor are defined when we define types.<br/>
  We will describe how to define types, in the next section.<br/>
</p>

<p>
  We give some other examples.<br/>
</p>

<pre>
  <code>
&gt; (test (match {5 2 1 3 4} (Multiset Int)
          {[&lt;cons $n
             &lt;cons ,(- n 1)
              &lt;cons ,(- n 2)
               &lt;cons ,(- n 3)
                &lt;cons ,(- n 4)
                 &lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [ _ &lt;ko&gt;]}))
&lt;ok&gt;
&gt; (test (match-all {1 2 3} (List Int)
          [&lt;join $hs &lt;cons $x $ts&gt;&gt; [hs x ts]]))
{[{} 1 {2 3}] [{1} 2 {3}] [{1 2} 3 {}]}
&gt; (test (match-all {1 2 3 4 5} (Multiset Int)
          [&lt;cons $n $rest&gt; [m rest]]))
{[1 {2 3 4 5}] [2 {1 3 4 5}] [3 {1 2 4 5}] [4 {1 2 3 5}] [5 {1 2 3 4}]}
  </code>
</pre>

<h2>How To Define Types</h2>

<p>
  We need to define how to do pattern matching for each type of data to evaluate the pattern matching expression explained in the previous section.<br/>
  In this section, we explain how to define type and how the pattern matching expressions of Egison are executed.<br/>
  All the knowledge you need to write type definitions is included in the type definition for multiset.<br/>
  Therefore, we explain type definiton with examples of the type definition for multiset.<br/>
  Below is a definition of the multiset in Egison.<br/>
</p>

<pre>
  <code>
(define $Multiset
  (lambda [$a]
    (type
      {[$var-match (lambda [$tgt] {tgt})]
       [$inductive-match
        (deconstructor
          {[nil []
            {[{} {[]}]
             [_ {}]}]
           [cons [a (Multiset a)]
            {[$tgt (map (lambda [$t] [t ((remove a) tgt t)]) tgt)]}]
           [join [(Multiset a) (Multiset a)]
            {[$tgt (map (lambda [$ts] [ts ((remove-collection a) tgt ts)])
                        (subcollections tgt))]}]})]
       [$equal?
        (lambda [$val $tgt]
          (match [val tgt] [(Multiset a) (Multiset a)]
            {[[&lt;nil&gt; &lt;nil&gt;] &lt;true&gt;]
             [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] &lt;true&gt;]
             [[_ _] &lt;false&gt;]}))]})))
  </code>
</pre>


<p>
  <code>remove</code> is a function that obtains a type and returns a function that removes the value which is its first argument from the collection which is its seconds argument.<br/>
  <code>remove-collection</code> is a function that obtains a type and returns a function that removes all elements of the collection which is its first argument from the collection which is its seconds argument.<br/>
</p>

<p>
  <code>Multiset</code> is defined as a function that obtains a type and returns a multiset type of that type.<br/>
  For example, <code>(Multiset Int)</code> means a multiset of an integer, and <code>(Multiset (Multiset Int))</code> means a multiset of a multiset of an integer.<br/>
</p>

<p>
  Types are defined with <code>type</code> expressions.<br/>
  Type expressions obtain a collection of tuples of a pattern variable and an expression as the first argument.<br/>
  Definitions of type expressions are mutually recursive with those of let expressions.<br/>
  With type-ref expressions, we can refer to the value bind with type expressions.<br/>
</p>

<p>
  To define <code>Multiset</code>, we need to define the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function.<br/>
  The <i>match-function</i> is constructed with these three functions.<br/>
  The match-function is function that obtains a pattern and a target value, and returns binding frames.<br/>
  The match-function is automatically constructed from the definition of the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function.<br/>
</p>

<p>
  Next, we describe the <code>var-match</code> function, the <code>inductive-match</code> function, and the <code>equal?</code> function, respectively.<br/>
</p>

<p>
  The <code>var-match</code> function is used when the pattern is a <i>variable pattern</i>.<br/>
  The variable pattern is a pattern that consist of only pattern variable.<br/>
  The elements of collection value returned by appling the target value to the  <code>var-match</code> function is the values that the pattern variable would be bound.<br/>
  In this <code>Multiset</code> examplen, the values that the pattern variable would be bound is only a target value.<br/>
</p>

<p>
  The <code>inductive-match</code> function is used when the pattern is a <i>inductive pattern</i>.<br/>
  The inductive pattern is a pattern that is constructed by a pattern constructor.<br/>
  We will discribe the <code>inductive-match</code> function after we described the <code>equal?</code> function.<br/>
</p>

<p>
  The <code>equal?</code> function is used when pattern is a <i>value pattern</i>.<br/>
  The boolean value returned by appling the value of the value pattern and the target value to the <code>equal?</code> function shows the result of the pattern matching.<br/>
  In this example, the <code>equal?</code> function is recursively defined.<br/>
  This <code>equal?</code> function returns <code>&lt;true&gt;</code>, if both arguments contains same element same count, and else return <code>&lt;false&gt;</code>.<br/>
</p>

<p>
  Now, we describe the <code>inductive-match</code> function.<br/>
  The <code>inductive-match</code> function is defined with the <code>deconstructor</code> expression.<br/>
  The <code>deconstructor</code> expression takes a collection of <i>deconstructor-match clause</i> as an argument.<br/>
  The deconstruct-match clause consist of a patttern constructer, an expression, whose value is a tuple of types, and <i>primitive match clause</i>.<br/>
  For example, we explain the deconstructor-match clause on <code>cons</code> for <code>Multiset</code>.<br/>
  The expression <code>[a (Multiset a)]</code> means that if the pattern constructor of the pattern is <code>cons</cons>, we do pattern matching the first argument of the inductive value as the type <code>a</code>, and the second as <code>(Multiset a)</code>.<br/>
</p>

<p>
  The primitive match clause is represented as a tuple of <i>primitive pattern</i> and an expression.<br/>
  If the target value is matched with the primitive pattern of the primitive match clause, the expression of the primitive match clauses are evaluated, and the value is the next target value of recursive pattern matching.<br/>
</p>

<p>
  For example, the case that the pattern is inductive pattern <code>&lt;cons $x $xs&gt;</code>, the target is a collection <code>{1 2 3}</code> and we do patten matching them as the type <code>(Multiset Int)</code>, pattern matching is executed using the <code>inductive-match</code> function.<br/>
  And in that case, the pattern is matched with the deconstructor-match clause of <code>cons</code>, and the target is matched with its only primitive match clause.<br/>
  And result of evaluating the expression of the primitive match clause is <code>{[1 {2 3}] [2 {1 3}] [3 {1 2}]}</code>.<br/>
  Each element of the result are the target of next pattern matching.<br/>
  Its first element is matched as <code>Int</code> and its second is matched as <code>(Multiset Int)</code>.<br/>
</p>

<p>
  We call pattern matching for primitive pattern as <i>primitive pattern matching</i>.<br/>
  Primitive pattern matching for primitive pattern returns only one binding frame, as ordinary pattern matching do.<br/>
  Primitive pattern matchicng is the pattern matching that human can do in their mind intuitively.<br/>
</p>

<p>
  There are 7 kinds of primitive patterns.<br/>
</p>

<pre>
primpat ::= _
          | patvar
          | &lt; cons primpat ... &t;
          | [ primpat ... ]
          | {}
          | { primpat .primpat }
          | { .primepat primepat }
</pre>

<p>
  '<code>_</code>' is wildcard.<br/>
  This matches with any value.<br/>
</p>

<p>
  <i>pat-var</i> is a pattern variable.<br/>
  This matches with any value too.<br/>
</p>

<p>
  <code>&lt;</code><i>cons</i> <i>prime-pat</i> <i>...</i> <code>&gt;</code> is called <i>inductive prime pattern</i>.<br/>
  This pattern matches when the target value is an inductive value whose constructor is <code>cons</code>.<br/>
  Pattern matchings for each arguments of the constructor are recursively executed.<br/>
</p>

<p>
  <code>[</code><i>prime-pat</i> <i>...</i> <code>]</code> is called <i>tuple prime pattern</i>.<br/>
  This pattern matches when the target value is a tuple.<br/>
  Pattern matchings for each elements of tuple are recursively executed.<br/>
</p>

<p>
  <code>{}</code> is called <i>empty pattern</i>.<br/>
  This pattern match when target is a empty collection.<br/>
</p>

<p>
  <code>{</code><i>prime-pat</i> <code>.</code><i>prime-pat</i><code>}</code> is called <i>cons pattern</i>.<br/>
  This pattern matches when target collection contain more than one element.<br/>
  The first <i>prime-pat</i> is matched with the first element of target collection, and the second <i>prime-pat</i> is matched with the rest elements of target collection.<br/>
</p>

<p>
  <code>{</code><code>.</code><i>prime-pat</i> <i>prime-pat</i><code>}</code> is called <i>snoc pattern</i>.<br/>
  This pattern matches when target collection contain more than one element.<br/>
  The second <i>prime-pat</i> is matched with the last element of target collection, and the first <i>prime-pat</i> is matched with the rest elements of target collection.<br/>
</p>

<p>
  We can define lists and sets, as we do for multisets.<br/>
  We can define the type of lists as figure 2.<br/>
  In the pattern of primitive pattern match clause of <code>nil</code>, there is a empty pattern.<br/>
  In the pattern of primitive pattern match clause of <code>cons</code>, there is a cons pattern.<br/>
  In the pattern of primitive pattern match clause of <code>snoc</code>, there is a snoc pattern.<br/>
</p>

<pre>
  <code>
(define $List
  (lambda [$a]
    (type
      {[$var-match (lambda [$tgt] {tgt})]
       [$inductive-match
        (deconstructor
          {[nil []
            {[{} {[]}]
             [_ {}]}]
           [cons [a (List a)]
            {[{$x .$xs} {[x xs]}]
             [_ {}]}]
           [snoc [a (List a)]
            {[{.$xs $x} {[x xs]}]
             [_ {}]}]
           [join [(List a) (List a)]
            {[$tgt (let {[$loop (lambda [$ts]
                                  (match ts (List a)
                                    {[&lt;nil&gt; {[{} {}]}]
                                     [&lt;cons $x $xs&gt; {[{} ts] @(map (lambda [$as $bs] [{x @as} bs])
                                                                   (loop xs))}]}))]}
                   (loop tgt))]}]
           [nioj [(List a) (List a)]
            {[$tgt (let {[$loop (lambda [$ts]
                                  (match ts (List a)
                                    {[&lt;nil&gt; {[{} {}]}]
                                     [&lt;snoc $x $xs&gt; {[{} ts] @(map (lambda [$as $bs] [{@as x} bs])
                                                                   (loop xs))}]}))]}
                   (loop tgt))]}]})]
       [$equal? (lambda [$val $tgt]
                  (match [val tgt] [(List a) (List a)]
                    {[[&lt;nil&gt; &lt;nil&gt;] &lt;true&gt;]
                     [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;]
                      &lt;true&gt;]
                     [[_ _] &lt;false&gt;]}))]})))
  </code>
</pre>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://hagi.is.s.u-tokyo.ac.jp/~egi/">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
