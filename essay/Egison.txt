Egisonの価値


パターンマッチについて考えることは，多くのひとが思っているより非常に重要なことである．
新しい強力なパターンマッチの表現をみつけることは，関数型言語や論理型言語，
オブジェクト指向言語などのアイデアと較べるとそこまで重要なことではないという認識がある．
しかし，そんな認識は間違っていて，
私が新しく開発した超強力なパターンマッチ機能をもつEgisonが，
実はどれだけ影響力を秘めた言語であるかということを今回は書いてみようと思う．

プログラミング言語には大雑把に分けて，
計算機を制御するための道具としての捉え方と，
アルゴリズムを表現するための道具としての捉え方があるように思う．
前者の捉え方は，入出力やメモリ管理，並列計算，ネットワーク関連の処理などの
コンピュータの機能を組み合わせて，
役に立つ便利なアプリケーションを作るハッカー的な捉え方である．
後者の捉え方は，コンピュータを本当にただの計算するための機械として使っているひとたちや，
プログラミングのためにプログラミングするようなひとたちに多い捉え方である．

それはさておき，純粋に後者の捉え方をすると，
プログラミング言語の進歩は冗長性を排除と言い換えることができる．
例えば，SchemeやHaskellなどの関数型言語に実装されている関数を第一級オブジェクトとして扱う機構は，
高階関数を記述する際の冗長性を排除した．
オブジェクト指向プログラミングのクラス定義の機構は，似たデータ型の定義を重複せずに書くための機構である．
また，ガベージコレクションは，冗長なメモリ管理の手続きを省略させてくれる機構である．

人間が頭の中では当たり前に行なっているにも関わらず，
プログラムでは当たり前に書けない処理があれば，そこが冗長性のある部分である．

プログラミング言語が洗練され，多くの冗長性が排除されてきたが，それでもまだ
冗長性が一番目立っている部分は，データの分解の処理、つまりパターンマッチの表現である．
よくある例としては，集合などのような順序の関係ないコレクションを扱う際，
いちいち順序を持つコレクションであるリストとして捉え直して扱わなければならないというものがある．
これは一般的にいうと，正規形(a canonical form)を持たないデータに対してパターンマッチが直接的にできない
というようにいえる．
正規形というのは，同じデータに対する1つの標準的な表現のことである．
集合は，正規形を持たないデータ型のもっとも知られているわかりやすい例である．
例えば，{a, b, c}という集合は，{b, a, c}や{a, a, c, b}という形でも表せる．
ソートして小さい順に並べたものを1つの標準的な表現を決めることができそうだが，
集合の要素にいつでも順序関係があるとは限らないし，
そもそもソートできた場合でも，それによってパターンマッチが便利になるのはごく一部のパターンだけで
多くの場合，パターンマッチの方法に制限がかかり，パターンマッチの記述は煩雑のままである．

このようにパターンマッチが上手く表現できないデータがある原因は，データの構成，分解の方法に単純なものしか用意されていないことである．
データを構成する方法は，決まった有限のデータを受け取るように定義されたデータコンストラクタに
データを渡すという単純なものだけであるし，
データを解釈する方法は，その単純な定義に基づいてそれぞれの要素にアクセスするというものだけである．
データの構成する方法や解釈する方法は，C言語の構造体の考え方から未だにほとんど進化していない．

アルゴリズムの表現において，データの解釈の表現，つまりはデータの分解の表現は大きな部位を占める．
それにも関わらず，大雑把なデータの構成，分解の方法しかプリミティブに用意されていないせいで，
多種多様なデータ分解に必要な一般的な処理を使いやすい形でモジュール化することができない．

Egisonはそこを解決したプログラミング言語である．
Egisonでは，例えば集合やマルチセットなどリスト以外の正規形を持たないデータに対してでも行うことができる一般的なパターンマッチの方法を記述できる．
それにより，ほぼ全てのアルゴリズムの表現がEgisonで記述することによって簡潔になる．

残念ながらEgisonにもまだまだ解決しなければならない問題がいくつもあるが，
Egisonは実はわりとかなり革命的な言語である．
